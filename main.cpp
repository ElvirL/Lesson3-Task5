/*
Задание 5. Пупырка
После посылки из Китая осталась спецплёнка для бережной перевозки груза — пупырка. Всего в пупырке 12 на 12 шариков-пузырьков. 
Состояние любого пузырька: он либо целый, либо нет, то есть true или false (тип массива — bool). 
Для начала требуется реализовать отдельную функцию инициализации пупырки начальным состоянием: полностью целая пупырка, все элементы true.
Программа заключается в последовательном лопании целых регионов пузырьков. Перед каждым таким лопанием надо показывать 
пользователю полностью всю плёнку: o — это целый пузырёк, x — лопнутый. Это тоже надо выделить в отдельную функцию. 
Итак, как выглядит само лопание. Пользователь вводит две координаты: начала региона и конца региона. Процедура лопания пузырей должна 
быть реализована с помощью отдельной функции, все аргументы должны проверяться на валидность, что они в в рамках диапазона возможных 
значений, иначе должна быть выведена ошибка. После лопания каждого пузыря, который не был ещё лопнут до того, в консоль должно выводиться 
сообщение “Pop!”.
Лопание должно продолжаться до последнего пузырька. Как только вся пупырка потрачена, программа заканчивает выполнение. Вы можете 
подсчитать окончание в самой функции по отображению пузырьков плёнки, так как функция выполняется после каждого лопания.

Советы и рекомендации
• Обратите внимание, что лопание пузырей делается с помощью региона, а не одной точки.
• Регион задаётся двумя координатами, это координаты углов прямоугольника.
• При лопании региона достаточно запустить цикл только по этим элементам. Не нужно проходить каждый раз по всей матрице.
• Всю область плёнки удобно представить в виде двумерного массива типа bool.
• Инициализировать вручную такой массив сложно, лучше воспользоваться вложенными циклами.
• Для проверки на целостность одной ячейки (если вы используете тип bool) можно не сравнивать её с истиной, а указать в условии 
имя переменной.
*/

#include <iostream>
#include <string>

using namespace std;

void initialization_matrix(bool matrix[12][12]){
    for (int i=0; i<12; ++i){
        for (int j=0; j<12; ++j){
            matrix[i][j] = true;
        }
    }
}

void print_matrix(bool matrix[12][12]){
    for (int i=0; i<12; ++i){
        for (int j=0; j<12; ++j){
            if (matrix[i][j])
                cout << "o" << " ";
            else
                cout << "x" << " ";
        }
        cout << endl;
    }
}

string check_correctness_points(int x1,int y1,int x2,int y2){
    if (x1 < 0 || x1 > 11 || y1 < 0 || y1 > 11 ||
        x2 < 0 || x2 > 11 || y2 < 0 || y2 > 11){
            return "Координаты должны быть в пределах [0,11]";
        }
    return "correct";
}

void bursting_bubbles(bool matrix[12][12]){
    int count_bursting_bubbles = 0;
    while (count_bursting_bubbles < 144){
        print_matrix(matrix);
        cout << endl;

        int x1,y1,x2,y2;
        cout << "Введите координаты первой точки: ";
        cin >> x1 >> y1;
        cout << "Введите координаты второй точки: ";
        cin >> x2 >> y2;

        if (check_correctness_points(x1,y1,x2,y2) == "correct"){
            int x_less,x_more,y_less,y_more;
            if (x1>=x2){
                x_less = x2;
                x_more = x1;
            }
            else {
                x_less = x1;
                x_more = x2;
            }
            if (y1>=y2){
                y_less = y2;
                y_more = y1;
            }
            else {
                y_less = y1;
                y_more = y2;
            }

            for (int i=x_less; i<=x_more;++i){
                for (int j=y_less; j<=y_more; ++j){
                    if (matrix[i][j]){
                        cout << "Pop!" << " ";
                        ++count_bursting_bubbles;
                        matrix[i][j] = false;
                    }
                }
            }
            cout << endl << endl;   
        }
        else {
            cout << check_correctness_points(x1,y1,x2,y2) << endl;
        }
    }
    print_matrix(matrix);
}

int main(){
    setlocale(LC_ALL,"Russian");
    bool matrix[12][12];
    initialization_matrix(matrix);

    bursting_bubbles(matrix);
}